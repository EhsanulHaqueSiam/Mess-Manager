import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_performance/firebase_performance.dart';
import 'package:firebase_remote_config/firebase_remote_config.dart';
import 'package:firebase_app_check/firebase_app_check.dart';
import 'package:flutter/foundation.dart';

/// Firebase Service
/// Handles Firebase initialization with all free tier services
///
/// Security Features:
/// - App Check: Protects backend from unauthorized access
/// - Firestore Rules: Data access control
/// - Authentication: User verification
class FirebaseService {
  static FirebaseAnalytics? _analytics;
  static FirebaseAnalyticsObserver? _observer;
  static FirebasePerformance? _performance;
  static FirebaseRemoteConfig? _remoteConfig;

  /// Initialize all Firebase services
  static Future<void> initialize() async {
    // Skip Firebase on web - requires firebase_options.dart to have web config
    // Run `flutterfire configure` to add web support
    if (kIsWeb) {
      debugPrint(
        'FirebaseService: Skipped on web platform (run flutterfire configure for web support)',
      );
      return;
    }

    await Firebase.initializeApp(
      // Options will be generated by FlutterFire CLI
      // Run: flutterfire configure
    );

    // ============ APP CHECK (Security) ============
    // Protects backend resources from abuse
    // Prevents unauthorized API calls
    await _initAppCheck();

    // ============ CRASHLYTICS ============
    if (!kIsWeb) {
      // Pass all uncaught errors to Crashlytics
      FlutterError.onError = (errorDetails) {
        FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
      };

      // Pass all uncaught asynchronous errors
      PlatformDispatcher.instance.onError = (error, stack) {
        FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
        return true;
      };

      // Disable in debug mode
      await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(
        !kDebugMode,
      );
    }

    // ============ ANALYTICS ============
    _analytics = FirebaseAnalytics.instance;
    _observer = FirebaseAnalyticsObserver(analytics: _analytics!);

    // ============ PERFORMANCE MONITORING ============
    _performance = FirebasePerformance.instance;
    // Disable in debug mode for cleaner logs
    await _performance?.setPerformanceCollectionEnabled(!kDebugMode);

    // ============ REMOTE CONFIG ============
    await _initRemoteConfig();
  }

  /// Initialize App Check for security
  static Future<void> _initAppCheck() async {
    try {
      await FirebaseAppCheck.instance.activate(
        // Use debug provider for development
        androidProvider: kDebugMode
            ? AndroidProvider.debug
            : AndroidProvider.playIntegrity,
        appleProvider: kDebugMode
            ? AppleProvider.debug
            : AppleProvider.appAttest,
        // Web uses reCAPTCHA
        webProvider: ReCaptchaV3Provider('your-recaptcha-site-key'),
      );

      // Listen for token changes
      FirebaseAppCheck.instance.onTokenChange.listen((token) {
        if (kDebugMode) {
          debugPrint('App Check token refreshed');
        }
      });
    } catch (e) {
      if (kDebugMode) {
        debugPrint('App Check initialization failed: $e');
      }
    }
  }

  /// Initialize Remote Config
  static Future<void> _initRemoteConfig() async {
    try {
      _remoteConfig = FirebaseRemoteConfig.instance;

      // Set defaults
      await _remoteConfig!.setDefaults({
        'meal_rate_default': 1.0,
        'meal_reminder_morning': '09:00',
        'meal_reminder_evening': '17:00',
        'night_preview_time': '21:00',
        'maintenance_mode': false,
        'min_app_version': '1.0.0',
        'show_ads': false,
      });

      // Fetch with 1 hour cache (free tier friendly)
      await _remoteConfig!.setConfigSettings(
        RemoteConfigSettings(
          fetchTimeout: const Duration(minutes: 1),
          minimumFetchInterval: const Duration(hours: 1),
        ),
      );

      // Fetch and activate
      await _remoteConfig!.fetchAndActivate();
    } catch (e) {
      if (kDebugMode) {
        debugPrint('Remote Config initialization failed: $e');
      }
    }
  }

  // ==================== ANALYTICS ====================

  /// Get Analytics instance
  static FirebaseAnalytics get analytics {
    if (_analytics == null) {
      throw Exception('Firebase not initialized');
    }
    return _analytics!;
  }

  /// Get Analytics Observer for navigation tracking
  static FirebaseAnalyticsObserver get observer {
    if (_observer == null) {
      throw Exception('Firebase not initialized');
    }
    return _observer!;
  }

  /// Log custom event
  static Future<void> logEvent({
    required String name,
    Map<String, Object>? parameters,
  }) async {
    await _analytics?.logEvent(name: name, parameters: parameters);
  }

  /// Set user ID for analytics
  static Future<void> setUserId(String? userId) async {
    await _analytics?.setUserId(id: userId);
    if (!kIsWeb && userId != null) {
      await FirebaseCrashlytics.instance.setUserIdentifier(userId);
    }
  }

  /// Log screen view
  static Future<void> logScreenView({
    required String screenName,
    String? screenClass,
  }) async {
    await _analytics?.logScreenView(
      screenName: screenName,
      screenClass: screenClass,
    );
  }

  // ==================== REMOTE CONFIG ====================

  /// Get remote config value
  static String getString(String key) {
    return _remoteConfig?.getString(key) ?? '';
  }

  static bool getBool(String key) {
    return _remoteConfig?.getBool(key) ?? false;
  }

  static int getInt(String key) {
    return _remoteConfig?.getInt(key) ?? 0;
  }

  static double getDouble(String key) {
    return _remoteConfig?.getDouble(key) ?? 0.0;
  }

  /// Check if app is in maintenance mode
  static bool get isMaintenanceMode => getBool('maintenance_mode');

  /// Get minimum app version
  static String get minAppVersion => getString('min_app_version');

  /// Refresh remote config
  static Future<bool> refreshConfig() async {
    try {
      return await _remoteConfig?.fetchAndActivate() ?? false;
    } catch (e) {
      return false;
    }
  }

  // ==================== PERFORMANCE ====================

  /// Start a custom trace
  static Future<Trace?> startTrace(String name) async {
    try {
      final trace = _performance?.newTrace(name);
      await trace?.start();
      return trace;
    } catch (e) {
      return null;
    }
  }

  /// Create HTTP metric
  static HttpMetric? createHttpMetric(String url, HttpMethod method) {
    return _performance?.newHttpMetric(url, method);
  }

  // ==================== CRASHLYTICS ====================

  /// Log error to Crashlytics
  static Future<void> logError(
    dynamic error,
    StackTrace? stack, {
    String? reason,
    bool fatal = false,
  }) async {
    if (!kIsWeb) {
      await FirebaseCrashlytics.instance.recordError(
        error,
        stack,
        reason: reason,
        fatal: fatal,
      );
    }
    if (kDebugMode) {
      debugPrint('Error: $error');
      if (stack != null) debugPrint('Stack: $stack');
    }
  }

  /// Add custom log message
  static Future<void> log(String message) async {
    if (!kIsWeb) {
      await FirebaseCrashlytics.instance.log(message);
    }
    if (kDebugMode) {
      debugPrint('[Firebase Log] $message');
    }
  }

  /// Set custom key for crash reports
  static Future<void> setCustomKey(String key, Object value) async {
    if (!kIsWeb) {
      await FirebaseCrashlytics.instance.setCustomKey(key, value);
    }
  }
}
